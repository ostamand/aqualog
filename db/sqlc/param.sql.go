// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: param.sql

package db

import (
	"context"
	"time"
)

const createParam = `-- name: CreateParam :one
INSERT INTO params (
  user_id,
  param_type_id,
  value,
  timestamp
) VALUES (
  $1,
  $2,
  $3,
  $4
) 
RETURNING id, user_id, param_type_id, value, timestamp, created_at
`

type CreateParamParams struct {
	UserID      int64     `json:"user_id"`
	ParamTypeID int64     `json:"param_type_id"`
	Value       float64   `json:"value"`
	Timestamp   time.Time `json:"timestamp"`
}

func (q *Queries) CreateParam(ctx context.Context, arg CreateParamParams) (Param, error) {
	row := q.db.QueryRowContext(ctx, createParam,
		arg.UserID,
		arg.ParamTypeID,
		arg.Value,
		arg.Timestamp,
	)
	var i Param
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParamTypeID,
		&i.Value,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

const getParam = `-- name: GetParam :one
SELECT id, user_id, param_type_id, value, timestamp, created_at FROM params
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetParam(ctx context.Context, id int64) (Param, error) {
	row := q.db.QueryRowContext(ctx, getParam, id)
	var i Param
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParamTypeID,
		&i.Value,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

const getParamByID = `-- name: GetParamByID :one
SELECT 
p.id as param_id,
t.id as param_type_id,
p."value",
p.timestamp,
t."name",
CASE WHEN t.target IS NULL THEN -999 ELSE t.target END AS target,
CASE WHEN t."min" IS NULL THEN -999 ELSE t."min" END AS "min",
CASE WHEN t."max" IS NULL THEN -999 ELSE t."max" END AS "max",
p.created_at
FROM params as p
INNER JOIN param_types AS t ON p.param_type_id = t.id
WHERE p.user_id=$2 AND p.id = $1
LIMIT 1
`

type GetParamByIDParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetParamByIDRow struct {
	ParamID     int64       `json:"param_id"`
	ParamTypeID int64       `json:"param_type_id"`
	Value       float64     `json:"value"`
	Timestamp   time.Time   `json:"timestamp"`
	Name        string      `json:"name"`
	Target      interface{} `json:"target"`
	Min         interface{} `json:"min"`
	Max         interface{} `json:"max"`
	CreatedAt   time.Time   `json:"created_at"`
}

func (q *Queries) GetParamByID(ctx context.Context, arg GetParamByIDParams) (GetParamByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getParamByID, arg.ID, arg.UserID)
	var i GetParamByIDRow
	err := row.Scan(
		&i.ParamID,
		&i.ParamTypeID,
		&i.Value,
		&i.Timestamp,
		&i.Name,
		&i.Target,
		&i.Min,
		&i.Max,
		&i.CreatedAt,
	)
	return i, err
}

const listParamsByType = `-- name: ListParamsByType :many
SELECT p.id, p.value, p.timestamp, p.created_at 
FROM params as p
INNER JOIN param_types as t ON p.param_type_id = t.id
WHERE p.user_id = $1
	AND t.name = $2
	AND p.timestamp >= $3
	AND p.timestamp < $4
ORDER BY p.timestamp DESC
LIMIT $6
OFFSET $5
`

type ListParamsByTypeParams struct {
	UserID        int64     `json:"user_id"`
	ParamTypeName string    `json:"param_type_name"`
	From          time.Time `json:"from"`
	To            time.Time `json:"to"`
	Offset        int32     `json:"offset"`
	Limit         int32     `json:"limit"`
}

type ListParamsByTypeRow struct {
	ID        int64     `json:"id"`
	Value     float64   `json:"value"`
	Timestamp time.Time `json:"timestamp"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) ListParamsByType(ctx context.Context, arg ListParamsByTypeParams) ([]ListParamsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listParamsByType,
		arg.UserID,
		arg.ParamTypeName,
		arg.From,
		arg.To,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListParamsByTypeRow{}
	for rows.Next() {
		var i ListParamsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
